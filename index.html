<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>aespa TETRIS 💜</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        const Play = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polygon points="5 3 19 12 5 21 5 3"></polygon>
            </svg>
        );

        const RotateCw = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="23 4 23 10 17 10"></polyline>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
            </svg>
        );

        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const BLOCK_SIZE = 30;

        const AESPA_MEMBERS = [
          { 
            name: 'KARINA', 
            color: 'bg-pink-500', 
            border: 'border-pink-600',
            images: [
'https://i.ibb.co.com/ccTsDjCp/Karina-1.jpg',
'https://i.ibb.co.com/Kj3hnsPH/Karina-2.jpg',
'https://i.ibb.co.com/7NRVsFtG/Karina-3.jpg',
'https://i.ibb.co.com/Q3wRpRJW/Karina-4.jpg',
'https://i.ibb.co.com/qLBwpLFZ/Karina-5.jpg',
'https://i.ibb.co.com/7N845Dm1/Karina-6.jpg'
            ]
          },
          { 
            name: 'GISELLE', 
            color: 'bg-purple-500', 
            border: 'border-purple-600',
            images: [
'https://i.ibb.co.com/jkNXNRGw/Giselle-1.jpg',
'https://i.ibb.co.com/4ZkbVB2c/Giselle-2.jpg',
'https://i.ibb.co.com/fYr4b2pm/Giselle-3.jpg',
'https://i.ibb.co.com/XrgBnWZK/Giselle-4.jpg',
'https://i.ibb.co.com/v6hP8SDt/Giselle-5.jpg',
'https://i.ibb.co.com/twPtfbyt/Giselle-6.jpg'
            ]
          },
          { 
            name: 'WINTER', 
            color: 'bg-blue-500', 
            border: 'border-blue-600',
            images: [
'https://i.ibb.co.com/MDcw9j51/Winter-1.jpg',
'https://i.ibb.co.com/fw0rTBR/Winter-2.jpg',
'https://i.ibb.co.com/rfwLGgX8/Winter-3.jpg',
'https://i.ibb.co.com/0ptXpN6G/Winter-4.jpg',
'https://i.ibb.co.com/QjdSY4Cp/Winter-5.jpg',
'https://i.ibb.co.com/C5Xj7mYG/Winter-6.jpg'
            ]
          },
          { 
            name: 'NINGNING', 
            color: 'bg-yellow-400', 
            border: 'border-yellow-500',
            images: [
'https://i.ibb.co.com/hxtBT90B/Ning-1.jpg',
'https://i.ibb.co.com/ksFW5sYz/Ning-2.jpg',
'https://i.ibb.co.com/XZcBMD22/Ning-3.jpg',
'https://i.ibb.co.com/4wrFKPnN/Ning-4.jpg',
'https://i.ibb.co.com/2YY0WXSH/Ning-5.jpg',
'https://i.ibb.co.com/FbnFYLj5/Ning-6.jpg'
            ]
          }
        ];

        const SHAPES = [
          [[1, 1, 1, 1]], // I
          [[1, 1], [1, 1]], // O
          [[0, 1, 0], [1, 1, 1]], // T
          [[1, 0, 0], [1, 1, 1]], // L
          [[0, 0, 1], [1, 1, 1]], // J
          [[0, 1, 1], [1, 1, 0]], // S
          [[1, 1, 0], [0, 1, 1]] // Z
        ];

        const AespaTetris = () => {
          const [board, setBoard] = useState([]);
          const [currentPiece, setCurrentPiece] = useState(null);
          const [position, setPosition] = useState({ x: 0, y: 0 });
          const [score, setScore] = useState(0);
          const [gameOver, setGameOver] = useState(false);
          const [gameStarted, setGameStarted] = useState(false);
          const [level, setLevel] = useState(1);
          const [touchStart, setTouchStart] = useState(null);
          const [touchEnd, setTouchEnd] = useState(null);

          const createEmptyBoard = () => {
            return Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(null));
          };

          const createNewPiece = () => {
            const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
            const memberTemplate = AESPA_MEMBERS[Math.floor(Math.random() * AESPA_MEMBERS.length)];
            
            const randomImage = memberTemplate.images[Math.floor(Math.random() * memberTemplate.images.length)];
            
            const member = {
              name: memberTemplate.name,
              color: memberTemplate.color,
              border: memberTemplate.border,
              image: randomImage
            };
            
            return { shape, member };
          };

          const initGame = () => {
            setBoard(createEmptyBoard());
            setCurrentPiece(createNewPiece());
            setPosition({ x: Math.floor(BOARD_WIDTH / 2) - 1, y: 0 });
            setScore(0);
            setLevel(1);
            setGameOver(false);
            setGameStarted(true);
          };

          const checkCollision = (piece, pos, boardState) => {
            for (let y = 0; y < piece.shape.length; y++) {
              for (let x = 0; x < piece.shape[y].length; x++) {
                if (piece.shape[y][x]) {
                  const newX = pos.x + x;
                  const newY = pos.y + y;
                  
                  if (newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT) {
                    return true;
                  }
                  
                  if (newY >= 0 && boardState[newY][newX]) {
                    return true;
                  }
                }
              }
            }
            return false;
          };

          const mergePieceToBoard = () => {
            const newBoard = board.map(row => [...row]);
            currentPiece.shape.forEach((row, y) => {
              row.forEach((cell, x) => {
                if (cell) {
                  const boardY = position.y + y;
                  const boardX = position.x + x;
                  if (boardY >= 0 && boardY < BOARD_HEIGHT && boardX >= 0 && boardX < BOARD_WIDTH) {
                    newBoard[boardY][boardX] = currentPiece.member;
                  }
                }
              });
            });
            return newBoard;
          };

          const clearLines = (boardState) => {
            let linesCleared = 0;
            const newBoard = boardState.filter(row => {
              if (row.every(cell => cell !== null)) {
                linesCleared++;
                return false;
              }
              return true;
            });
            
            while (newBoard.length < BOARD_HEIGHT) {
              newBoard.unshift(Array(BOARD_WIDTH).fill(null));
            }
            
            return { newBoard, linesCleared };
          };

          const moveDown = useCallback(() => {
            if (!currentPiece || gameOver || !gameStarted) return;

            const newPos = { ...position, y: position.y + 1 };
            
            if (!checkCollision(currentPiece, newPos, board)) {
              setPosition(newPos);
            } else {
              const newBoard = mergePieceToBoard();
              const { newBoard: clearedBoard, linesCleared } = clearLines(newBoard);
              
              setBoard(clearedBoard);
              setScore(prev => prev + linesCleared * 100 * level);
              setLevel(Math.floor(score / 1000) + 1);
              
              const nextPiece = createNewPiece();
              const startPos = { x: Math.floor(BOARD_WIDTH / 2) - 1, y: 0 };
              
              if (checkCollision(nextPiece, startPos, clearedBoard)) {
                setGameOver(true);
                setGameStarted(false);
              } else {
                setCurrentPiece(nextPiece);
                setPosition(startPos);
              }
            }
          }, [currentPiece, position, board, gameOver, gameStarted, score, level]);

          const moveLeft = () => {
            if (!currentPiece || gameOver) return;
            const newPos = { ...position, x: position.x - 1 };
            if (!checkCollision(currentPiece, newPos, board)) {
              setPosition(newPos);
            }
          };

          const moveRight = () => {
            if (!currentPiece || gameOver) return;
            const newPos = { ...position, x: position.x + 1 };
            if (!checkCollision(currentPiece, newPos, board)) {
              setPosition(newPos);
            }
          };

          const rotate = () => {
            if (!currentPiece || gameOver) return;
            const rotated = currentPiece.shape[0].map((_, i) =>
              currentPiece.shape.map(row => row[i]).reverse()
            );
            const rotatedPiece = { ...currentPiece, shape: rotated };
            
            if (!checkCollision(rotatedPiece, position, board)) {
              setCurrentPiece(rotatedPiece);
            }
          };

          const minSwipeDistance = 50;

          const onTouchStart = (e) => {
            setTouchEnd(null);
            setTouchStart({
              x: e.targetTouches[0].clientX,
              y: e.targetTouches[0].clientY
            });
          };

          const onTouchMove = (e) => {
            setTouchEnd({
              x: e.targetTouches[0].clientX,
              y: e.targetTouches[0].clientY
            });
          };

          const onTouchEnd = () => {
            if (!touchStart || !touchEnd || !gameStarted || gameOver) return;
            
            const distanceX = touchStart.x - touchEnd.x;
            const distanceY = touchStart.y - touchEnd.y;
            const isLeftSwipe = distanceX > minSwipeDistance;
            const isRightSwipe = distanceX < -minSwipeDistance;
            const isDownSwipe = distanceY < -minSwipeDistance;
            
            if (Math.abs(distanceX) > Math.abs(distanceY)) {
              if (isLeftSwipe) {
                moveLeft();
              } else if (isRightSwipe) {
                moveRight();
              }
            } else if (isDownSwipe) {
              moveDown();
            }
          };

          useEffect(() => {
            if (!gameStarted || gameOver) return;

            const handleKeyPress = (e) => {
              switch(e.key) {
                case 'ArrowLeft':
                  e.preventDefault();
                  moveLeft();
                  break;
                case 'ArrowRight':
                  e.preventDefault();
                  moveRight();
                  break;
                case 'ArrowDown':
                  e.preventDefault();
                  moveDown();
                  break;
                case 'ArrowUp':
                case ' ':
                  e.preventDefault();
                  rotate();
                  break;
              }
            };

            window.addEventListener('keydown', handleKeyPress);
            return () => window.removeEventListener('keydown', handleKeyPress);
          }, [gameStarted, gameOver, moveDown]);

          useEffect(() => {
            if (!gameStarted || gameOver) return;

            const speed = Math.max(200, 1000 - (level - 1) * 100);
            const timer = setInterval(moveDown, speed);
            return () => clearInterval(timer);
          }, [gameStarted, gameOver, moveDown, level]);

          const renderCell = (cell) => {
            if (!cell) return <div className="w-full h-full border border-gray-700 bg-gray-900"></div>;
            
            return (
              <div className={`w-full h-full border-2 ${cell.border} overflow-hidden`}>
                <img 
                  src={cell.image} 
                  alt={cell.name}
                  className="w-full h-full object-cover"
                />
              </div>
            );
          };

          const getDisplayBoard = () => {
            const displayBoard = board.map(row => [...row]);
            
            if (currentPiece) {
              currentPiece.shape.forEach((row, y) => {
                row.forEach((cell, x) => {
                  if (cell) {
                    const boardY = position.y + y;
                    const boardX = position.x + x;
                    if (boardY >= 0 && boardY < BOARD_HEIGHT && boardX >= 0 && boardX < BOARD_WIDTH) {
                      displayBoard[boardY][boardX] = currentPiece.member;
                    }
                  }
                });
              });
            }
            
            return displayBoard;
          };

          return (
            <div className="min-h-screen bg-gradient-to-br from-purple-900 via-pink-900 to-blue-900 flex items-center justify-center p-4">
              <div className="max-w-4xl w-full">
                <h1 className="text-5xl font-bold text-center mb-6 text-white drop-shadow-lg">
                  aespa TETRIS 💜
                </h1>
                
                <div className="flex flex-col md:flex-row gap-6 justify-center items-start">
                  <div className="bg-black/50 p-6 rounded-lg backdrop-blur">
                    <div 
                      className="grid gap-0 border-4 border-pink-500 shadow-2xl"
                      style={{
                        gridTemplateColumns: `repeat(${BOARD_WIDTH}, ${BLOCK_SIZE}px)`,
                        gridTemplateRows: `repeat(${BOARD_HEIGHT}, ${BLOCK_SIZE}px)`
                      }}
                      onTouchStart={onTouchStart}
                      onTouchMove={onTouchMove}
                      onTouchEnd={onTouchEnd}
                    >
                      {getDisplayBoard().map((row, y) =>
                        row.map((cell, x) => (
                          <div key={`${y}-${x}`} style={{ width: BLOCK_SIZE, height: BLOCK_SIZE }}>
                            {renderCell(cell)}
                          </div>
                        ))
                      )}
                    </div>

                    {gameStarted && !gameOver && (
                      <div className="mt-4 flex flex-col gap-2 md:hidden">
                        <div className="flex justify-center gap-2">
                          <button
                            onClick={rotate}
                            className="bg-purple-500 hover:bg-purple-600 active:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg flex items-center justify-center transition touch-none"
                          >
                            <RotateCw size={24} />
                          </button>
                        </div>
                        <div className="flex justify-center gap-2">
                          <button
                            onClick={moveLeft}
                            className="bg-blue-500 hover:bg-blue-600 active:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg text-2xl transition touch-none"
                          >
                            ←
                          </button>
                          <button
                            onClick={moveDown}
                            className="bg-blue-500 hover:bg-blue-600 active:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg text-2xl transition touch-none"
                          >
                            ↓
                          </button>
                          <button
                            onClick={moveRight}
                            className="bg-blue-500 hover:bg-blue-600 active:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg text-2xl transition touch-none"
                          >
                            →
                          </button>
                        </div>
                      </div>
                    )}
                  </div>

                  <div className="bg-black/50 backdrop-blur rounded-lg p-6 space-y-4 min-w-[200px]">
                    <div className="text-white space-y-2">
                      <div className="text-2xl font-bold">Score: {score}</div>
                      <div className="text-xl">Level: {level}</div>
                    </div>

                    {!gameStarted && (
                      <button
                        onClick={initGame}
                        className="w-full bg-gradient-to-r from-pink-500 to-purple-500 hover:from-pink-600 hover:to-purple-600 text-white font-bold py-3 px-6 rounded-lg flex items-center justify-center gap-2 transition"
                      >
                        <Play />
                        Start Game
                      </button>
                    )}

                    {gameOver && (
                      <div className="text-center">
                        <div className="text-red-500 font-bold text-xl mb-3">Game Over!</div>
                        <button
                          onClick={initGame}
                          className="w-full bg-gradient-to-r from-pink-500 to-purple-500 hover:from-pink-600 hover:to-purple-600 text-white font-bold py-3 px-6 rounded-lg flex items-center justify-center gap-2 transition"
                        >
                          <Play />
                          Play Again
                        </button>
                      </div>
                    )}

                    <div className="border-t border-gray-600 pt-4 text-white space-y-2">
                      <div className="font-bold text-lg mb-2">Controls:</div>
                      <div className="text-sm space-y-1">
                        <div className="hidden md:block">← → Move</div>
                        <div className="hidden md:block">↓ Drop faster</div>
                        <div className="hidden md:block">↑ / Space: Rotate</div>
                        <div className="md:hidden">Swipe to move</div>
                        <div className="md:hidden">Use buttons below</div>
                      </div>
                    </div>

                    <div className="border-t border-gray-600 pt-4 space-y-2">
                      <div className="text-white font-bold text-sm mb-2">Members:</div>
                      <div className="text-xs text-gray-300 mb-2">Each member has 6 different pictures!</div>
                      {AESPA_MEMBERS.map(member => (
                        <div key={member.name} className="flex items-center gap-2">
                          <div className={`w-6 h-6 ${member.color} border-2 ${member.border} rounded`}></div>
                          <span className="text-white text-sm">{member.name}</span>
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
 
                  {/* Credits Section */}
                <div className="mt-6 text-center">
                  <div className="bg-black/30 backdrop-blur rounded-lg p-4 inline-block">
                    <div className="text-white text-sm space-y-1">
                      <div className="font-bold">Created by: KWON88IM<span className="text-pink-400">Version 1.1</span></div>
                      <a 
                        href="https://twitter.com/kwon88im" 
                        target="_blank" 
                        rel="noopener noreferrer"
                        className="text-blue-400 hover:text-blue-300 transition"
                      >
                        @KWON88IM
                      </a>
                      <div className="text-gray-400 text-xs mt-2">Version 1.0.0</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          );
        };
                
        ReactDOM.render(<AespaTetris />, document.getElementById('root'));
    </script>
</body>
</html>
